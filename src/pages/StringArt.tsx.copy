import { useRef, useState, useEffect } from 'react';
import '../styles/pages/StringArt.scss';
import ImageInput from '../components/ImageInput';

async function getImageData(img: HTMLImageElement, width?: number, height?: number): Promise<Uint8ClampedArray> {
  await img.decode();

  const canvas = document.createElement('canvas');
  canvas.width = typeof(width) == 'undefined' ? img.width : width;
  const aspect = img.width / img.height;
  canvas.height = typeof(height) == 'undefined' ? canvas.width / aspect : height;

  const ctx = canvas.getContext('2d');
  if (!ctx) throw new Error("Couldn't create 2D context");

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, img.width, img.height).data;

  return imageData;
}

function getPixel(data: Uint8ClampedArray, width: number, x: number, y: number) {
  const index = (y * width + x) * 4;
  return [
    data[index],
    data[index + 1],
    data[index + 2],
    data[index + 3]
  ];
}

export default function StringArt() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  const initialNumNails = 40;
  const initialThreadWeight = 1;
  const initialReverseContrast = false;

  const [imageFile, setImageFile] = useState<File | undefined>();
  const [numNails, setNumNails] = useState<number>(initialNumNails);
  const [threadWeight, setThreadWeight] = useState<number>(initialThreadWeight);
  const [reverseContrast, setReverseContrast] = useState<boolean>(initialReverseContrast);

  const resetRefs = [
    useRef<HTMLDivElement>(null),
    useRef<HTMLDivElement>(null),
    useRef<HTMLDivElement>(null),
    useRef<HTMLDivElement>(null)
  ];

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.font = `${canvas.width / 29.25}px Consolas`;
    ctx.fillText('Upload an image and click generate to view results.', canvas.width / 51.2, canvas.width / 2.56);
    ctx.fillText("(trust me, it's good, not yet tho)", canvas.width / 51.2, canvas.width / 2.27);
  }, []);

  useEffect(() => {
    if (resetRefs[1].current) resetRefs[1].current.style.opacity = numNails === initialNumNails ? '0' : '1';
    if (resetRefs[2].current) resetRefs[2].current.style.opacity = threadWeight === initialThreadWeight ? '0' : '1';
    if (resetRefs[3].current) resetRefs[3].current.style.opacity = reverseContrast === initialReverseContrast ? '0' : '1';

    for (const ref of resetRefs) {
      if (ref.current) ref.current.style.cursor = ref.current.style.opacity === '1' ? 'pointer' : 'default';
    }

    if (resetRefs[0].current) resetRefs[0].current.style.opacity = '0';
  }, [numNails, threadWeight, reverseContrast]);

  async function generateStringArt() {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    if (!imageFile || !canvas || !ctx) return;
    function getError() { // Problem function
      if (!canvas || !ctx) return;

      const startX = Math.floor(img.width / 2) - radius;
      const startY = 0;
      const endX = Math.floor(img.width / 2) + radius;
      const endY = img.height;

      const canvasImageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

      let totalError = 0;

      for (let x = 0; x < endX - startX; x++) {
        for (let y = 0; y < endY - startY; y++) {
          if (Math.sqrt((x - canvas.width / 2) ** 2 + (y - canvas.height / 2) ** 2) < radius) continue;
          let [r, g, b, a] = getPixel(imageData, img.width, x + startX, y + startY);
          const imagePixelValue = a * (r + g + b) / 3;
          [r, g, b, a] = getPixel(canvasImageData, canvas.width, x, y);
          const canvasPixelValue = a * (r + g + b) / 3;
          const diff = imagePixelValue - canvasPixelValue;
          totalError += diff * diff;
        }
      }

      return totalError;
    }

    function getNailPos(nail: number) {
      const alpha = (nail / numNails) * 2 * Math.PI;
      return [
        radius * Math.cos(alpha) + radius - 1,
        radius * Math.sin(alpha) + radius - 1,
      ];
    }

    async function generateLines() {
      function drawLine(from: number, to: number) {
        if (!ctx) return;

        ctx.beginPath();
        let [x, y] = getNailPos(from);
        ctx.moveTo(x, y);
        [x, y] = getNailPos(to);
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      if (!ctx || !canvas) return;
      ctx.lineWidth = threadWeight;
      ctx.strokeStyle = reverseContrast ? 'white' : 'black';

      let prevError: number;
      let error = Infinity;
      let nail = 0;
      let prevCanvasState;
      for (let i = 0; i < 200; i++) {
        prevError = error;
        prevCanvasState = ctx.getImageData(0, 0, canvas.width, canvas.height);

        let errors: number[] = [];
        for (let i = 0; i < numNails; i++) {
          if (i === nail) {
            errors.push(prevError);
            continue;
          }

          drawLine(nail, i);

          const currentError = getError();
          if (typeof currentError === 'undefined') return;
          errors.push(currentError);

          ctx.putImageData(prevCanvasState, 0, 0)
        }

        error = Math.min(...errors);
        let bestNail = errors.indexOf(error);
        drawLine(nail, bestNail);
        nail = bestNail;
      }

      console.log(`error: ${error}`);
    }

    const radius = canvas.width / 2;

    const img = new Image();
    img.src = URL.createObjectURL(imageFile);
    const imageData = await getImageData(img, canvas.width);

    // Draw on canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.beginPath();
    ctx.arc(radius, radius, radius, 0, 2 * Math.PI);
    ctx.fillStyle = reverseContrast ? 'black' : 'white';
    ctx.fill();

    // await generateLines();
  }

  return (
    <main className='string-art'>
      <h1>String Art Generator</h1>
      <div>
        <div className='input-section'>
          <div className='labels'>
            <label>Input image:</label>
            <label>Number of nails:</label>
            <label>Thread weight:</label>
            <label>Reverse contrast:</label>
          </div>
          <div className='inputs'>
            <ImageInput onChange={e => {
              const file = e.target.files?.[0];
              if (file) setImageFile(file);
            }}/>
            <input type='text' value={String(numNails)} onChange={e => {
              const num = Number(e.target.value);
              if (!Number.isNaN(num)) setNumNails(num);
            }} />
            <input type='range' value={String((threadWeight - 0.5) / 0.015)} onChange={e => {
              const num = 0.015 * Number(e.target.value) + 0.5;
              setThreadWeight(num);
            }} />
            <input type='checkbox' checked={reverseContrast} onChange={e => {
              setReverseContrast(e.target.checked);
            }}/>
          </div>
          <div className='reset-buttons'>
            <div ref={resetRefs[0]} />
            <div ref={resetRefs[1]} onClick={_ => { setNumNails(initialNumNails) }} />
            <div ref={resetRefs[2]} onClick={_ => { setThreadWeight(initialThreadWeight) }} />
            <div ref={resetRefs[3]} onClick={_ => { setReverseContrast(initialReverseContrast) }} />
          </div>
          <button onClick={() => generateStringArt()}>Generate</button>
        </div>
        <canvas ref={canvasRef} width={500} height={500} />
      </div>
    </main>
  );
}
